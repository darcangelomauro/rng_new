import math 
import scipy.special

# convert 'num' to base 'base' and add zeroes to reach length 'length' 
def convert_base(num, base, length):
    ls = []
    while num != 0:
        ls.append(num % base)
        num = int(num/base)
    while len(ls) < length:
        ls.append(0)
    return ls

# return first cyclic permutation among all cyclic permutations 
def first_cyclic(ls):

    n = len(ls)
    b = [[ls[i - j] for i in range(n)] for j in range(n)]
    b.sort()

    return b[0]

def sort_lists(ls1, ls2):
    ls = []
    ls.append("_".join(ls1))
    ls.append("_".join(ls2))
    ls.sort()
    ls1_new = ls[0].split('_')
    
    if ls1_new == ls1:
        return 0
    else:
        return 1


def sum_terms(terms):
    
    check = 1
    while check:
        check = 0
        for i, termi in enumerate(terms):
            for j, termj in enumerate(terms):
                if j > i:
                    if len(termi) == len(termj):
                        equal = 1
                        for k in range(-1, -3, -1):
                            if type(termi[k]) == str and type(termj[k]) == str:
                                if termi[k] != termj[k]:
                                    equal *= 0
                        if equal:
                            for part in termj:
                                if type(part) == list:
                                    termi.insert(0, part)

                            terms.pop(j)
                            check = 1
                            break
            if check:
                break

    return terms

def sum2_terms(term):

    check = 1
    while check:
        check = 0
        for i, parti in enumerate(term):
            if type(parti) != str:
                for j, partj in enumerate(term):
                    if type(partj) != str and j > i:
                        if parti[1] == partj[1]:
                            parti[0] = parti[0] + '+' + partj[0]
                            term.pop(j)
                            check = 1
                            break
                if check:
                    break

    return term

# takes as input the string of gammas multiplied,
# separated by *
def gamma_table_name(gamma_string):
    if gamma_string.find('I_g') != -1:
        return 'gsl_complex_rect(dimG, 0.)'
    else:
        ls = gamma_string.split('*')
        n = str(len(ls))

        return 'gamma_table[' + n + '][' + index_gamma_table(ls) + ']'



# takes as an input the list of gammas multiplied 
# or the list of indices
def index_gamma_table(ls):

    # generate indices from gamma list
    idx = []
    for item in ls:
        temp1 = item.replace('gamma[', '')
        temp2 = temp1.replace(']]', ']')
        idx.append(temp2.replace('uM]', 'uM'))
    idx.reverse()

    n = 'nHL'

    idx_ls = [idx[0] + '+']
    del idx[0]

    for item in idx:
        idx_ls.append(n + '*(' + item + '+')

    idx_ls[-1] = idx_ls[-1].replace('+', '')

    for item in idx:
        idx_ls.append(')')

    return ''.join(idx_ls)

# takes as input the string fo matrices multiplied together
def matrix_multiprod_c_string(mat_string, i):
    
    ls = mat_string.split('*')
    n = len(ls)
    if len(ls) == 1:
        return 0

    print('gsl_matrix_complex** array' + str(i) + ' = malloc(' + str(n) + '*sizeof(gsl_matrix_complex*));')
    for idx, mat in enumerate(ls):
        print('array' + str(i) + '[' + str(idx) + '] = ' + mat + ';')
    print('gsl_matrix_complex* temp_mat' + str(i) + ' = gsl_matrix_complex_alloc(dim, dim);')
    print('matrix_multiprod(array' + str(i) + ', ' + str(n) + ', temp_mat' + str(i) + ');')

    return 1


# cleans traces of identity and 1*
def term_cleanup(term):

    '''
    for item in term:
        if item.find('I_g') != -1:
            term[0] = 'dimG*' + term[0]
            del term[term.index(item)]
    '''
    for idx, item in enumerate(term):
        if idx != 0:
            if item.find('I') != -1:
                term[0][0] = 'dim*' + term[0][0]
                del term[idx]
    for idx, item in enumerate(term):
        if idx != 0:
            if item.find('I') != -1:
                term[0][0] = 'dim*' + term[0][0]
                del term[idx]

    term[0][0] = term[0][0].replace('1*', '')
    term[0][0] = term[0][0].replace('*1', '')

    '''
    if term[1].find('gamma') != -1:
        term[0] = 'gsl_complex_mul(' + term[0] + ',' + ''.join(term[1]) + ')'
        del term[1]
    '''

    return term




n = input('input n: ')
n = int(n)

print('double delta' + str(n) + '(gsl_matrix_complex* dM, int uM)')
print('{')
print('// THIS CODE IS GENERATED BY delta.py SCRIPT (in the script folder)')
print('')
print('gsl_complex res = GSL_COMPLEX_ZERO;')
print('')

for s in range(1, n+1):
    print('// CASE: s=' + str(s))
    print('')
    terms = []
    
    # generate i indices
    i = []
    if n-s:
        print('int* i' + str(s) + ' = malloc(' + str(n-s) + '*sizeof(int));')
    for num_i in range(n-s):
        i.append('i' + str(s) + '[' + str(num_i) + ']')
        print('for(' + i[num_i] + '=0; ' + i[num_i] + '<nHL; ' + i[num_i] + '++)')
        print('{')

        
    # generate k indices and check that their sum is <= s 
    for num_k in range(int(math.pow(s+1, n-s))):
        k = convert_base(num_k, s+1, n-s)

        sum_k = 0
        for num in k:
            sum_k += num

        if sum_k <= s:
            
            # generate p indices and check that p[j] <= k[j] for all j
            for num_p in range(int(math.pow(s+1, n-s))):
                p = convert_base(num_p, s+1, n-s)

                check_p = 1
                for idx in range(len(p)):
                    if p[idx] > k[idx]:
                        check_p = 0
                        break

                if check_p:

                    # loop over l index
                    for l in range(s - sum_k + 1):

                        # generate q indices
                        for num_q in range(int(math.pow(2, n-s))):
                            q = convert_base(num_q, 2, n-s)

                            
                            # NOW THE INDICES ARE ALL SET

                            # 1. gamma matrices
                            first = []

                            for idx_1 in range(n-s):
                                for idx_k in range(k[idx_1]):
                                    first.append('gamma[uM]')
                                first.append('gamma[' + i[idx_1] + ']')
                            for idx_1 in range(s - sum_k):
                                first.append('gamma[uM]')
                            
                            first = first_cyclic(first)

                            # 2. simplify gammas (gamma[i] squares to identity)
                            check_2 = 1
                            while len(first) > 1 and check_2:

                                # this stops the while cycle if every pair has been accounted for
                                # in the last iteration
                                check_2 = 0

                                # check for pair matching
                                for idx_2 in range(len(first)-1):
                                    if first[idx_2] == first[idx_2+1]:

                                        # delete the two gammas
                                        del first[idx_2]
                                        del first[idx_2]
                                        
                                        # put and identity if there are no more gammas in the first term
                                        if not len(first):
                                            first.append('I_g')
                                        
                                        # break the cycle to avoid index shenanigans
                                        # but force another iteration in the while cycle   
                                        # (unless the term only has an identity in it)
                                        check_2 = 1
                                        break

                            # I dont think another cyclic permutation is needed, but just to be sure
                            first = first_cyclic(first)


                            # NOW THE GAMMA MATRICES ARE ALL SET


                            # 3. normal matrices
                            second = []
                            
                            for idx_3 in range(n-s):
                                for idx_p in range(p[idx_3]):
                                    second.append('dM')
                                for idx_q in range(q[idx_3]):
                                    second.append('MAT[' + i[idx_3] + ']')
                            for idx_3 in range(l):
                                second.append('dM')

                            if len(second):
                                second = first_cyclic(second)
                            else:
                                second.append('I')

                            # 4. transposed matrices
                            third = []
                            
                            for idx_4 in range(n-s):
                                for idx_pk in range(k[idx_4] - p[idx_4]):
                                    third.append('dM')
                                for idx_1q in range(1-q[idx_4]):
                                    third.append('MAT[' + i[idx_4] + ']')
                            for idx_4 in range(s - sum_k - l):
                                third.append('dM')

                            # account for transposition
                            third.reverse()

                            if len(third):
                                third = first_cyclic(third)
                            else:
                                third.append('I')


                            # 5. binomial coefficients
                            binom = 1

                            for idx_5 in range(n-s):
                                binom *= scipy.special.comb(k[idx_5], p[idx_5], exact=True)
                            binom *= scipy.special.comb(s-sum_k, l, exact=True)


                            # 6. e factors
                            e = []

                            for item in third:
                                if item.find('dM') != -1:
                                    e.append('e[uM]')
                                elif item.find('MAT') != -1:
                                    e.append(item.replace('MAT', 'e'))


                            # 7. simplify e (e[i] squares to 1)
                            for item in e:
                                occ = e.count(item)
                                e = [value for value in e if value != item]
                                if occ % 2:
                                    e.append(item)
                            if not len(e):
                                e.append('1')


                            # 8. order second and third
                            if sort_lists(second, third):
                                second, third = third, second


                            # NOW THE WHOLE TERM IS ALL SET 



                            # add everything to the full lists
                            
                            if len(first) > 1:
                                cliff = 'gamma_table[' + index_gamma_table(first) + ']'
                            else:
                                cliff = 'I_g'

                            terms.append([[str(binom) + '*' + '*'.join(e), '*'.join(first)], '*'.join(second), '*'.join(third)])

    for term in terms:
        term = term_cleanup(term)
    terms = sum_terms(terms)
    for term in terms:
        sum2_terms(term)
    
    # UP TO THIS POINT, THE LIST OF TERMS IS RELATIVELY
    # IMPLEMENTATION INDEPENDENT


    # NOW THE IMPLEMENTATION DEPENDENT PART BEGINS

    for idx_out, term in enumerate(terms):
        pfac = 'pfac' + str(idx_out)
        print('gsl_complex ' + pfac + ' = GSL_COMPLEX_ZERO;')
        for idx_in, part in enumerate(term):
            if type(part) == list:
                temp = gamma_table_name(part[1])
                print(pfac + ' = gsl_complex_add(' + pfac + ', gsl_complex_mul_real(' + temp + ', (double)' + part[0] + '));') 
        print('if(GSL_REAL(' + pfac + ') != 0. || GSL_IMAG(' + pfac + ') != 0.)')
        print('{')

        check_1 = 0
        check_2 = 0

        if type(term[-1]) == str:
            if matrix_multiprod_c_string(term[-1], 0):
                check_1 = 1
        if type(term[-2]) == str:
            if matrix_multiprod_c_string(term[-2], 1):
                check_2 = 1

        if check_1 and type(term[-1]) == str:
            if check_2 and type(term[-2]) == str:
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(temp_mat0));')
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(temp_mat1));')
                print('free(array0);')
                print('free(array1);')
                print('gsl_matrix_complex_free(temp_mat0);')
                print('gsl_matrix_complex_free(temp_mat1);')
            elif type(term[-2]) == str:
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(temp_mat0));')
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(' + term[-2] + '));')
                print('free(array0);')
                print('gsl_matrix_complex_free(temp_mat0);')
            else:
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(temp_mat0));')
                print('free(array0);')
                print('gsl_matrix_complex_free(temp_mat0);')
        elif type(term[-1]) == str:
            if check_2 and type(part[-2]) == str:
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(' + term[-1] + '));')
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(temp_mat1));')
                print('free(array1);')
                print('gsl_matrix_complex_free(temp_mat1);')
            elif type(term[-2]) == str:
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(' + term[-1] + '));')
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(' + term[-2] + '));')
            else:
                print(pfac + ' = gsl_complex_mul(' + pfac + ', trace(' + term[-1] + '));')


        print('res = gsl_complex_add(' + pfac + ', res);')




        print('}')


    
    for val in range(n-s):
        print('}')
    
    if n-s:
        print('free(i' + str(s) + ');')

    print('')
    print('')
    print('')
print('return GSL_REAL(res);')
print('}')

    
